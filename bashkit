#!/bin/bash

CWD="$PWD"
ARGV=("$@")
ARGV_=()
OPTS=()
IFS_DEFAULT=$IFS

cd $(dirname $(readlink $0 || echo $0))
DIRNAME=$PWD
FILENAME=$DIRNAME/$(basename $(readlink $0 || echo $0))
cd $CWD

__argv_ () {
	while [ $# != 0 ]; do
		if [ "${1:0:1}" = "-" ] && [ "${1:0:1}" != "$1" ]; then
			shift
			[ "${1:0:1}" != "-" ] && shift
		else
			ARGV_+=("$1")
			shift
		fi
	done
}

__argv_ "${ARGV[@]}"

silent () {
	$* > /dev/null 2> /dev/null
	return $?
}

error () {
	if [ "$BASHKIT_COLORS" = "" ]; then
		echo -e $* >&2
	else
		echo -e "\x1B[31m$*\x1B[39m" >&2
	fi
	exit 1
}

not () {
	$* && return 1 || return 0
}

opt-find-def () {
	local IFS=","
	opt-find ${2--} $1
}

opt-find () {
	local default=$1 && shift
	local name=${1//-/}
	local opt_name=opt_$name
	local found=false
	local IFS=$IFS_DEFAULT
	for opt in "$@"; do
		for arg in "${ARGV[@]}"; do
			[ "$opt" = "$arg" ] && found=true && printf -v $opt_name true && continue
			$found && [ "${arg:0:1}" = "-" ] && break 2
			$found && printf -v $opt_name "$arg" && break 2
		done
	done
	for alias in ${@:2}; do
		printf -v opt_alias_${alias//-/} $name
	done
	$found && return 0
	[ "$default" != "-" ] && printf -v $opt_name $default && return 0
	return 1
}

opt () {
	if [ "${1:0:1}" != "-" ]; then
		[ "${ARGV_[0]}" != "$1" ] && return 1
		shift
	fi
	local name=opt_${1//-/}
	[ $# = 1 ] && [ "${!name}" != "" ] && return 0
	OPTS+=(${@//,[^ ]*/})
	for group in "$@"; do
		local IFS="="
		opt-find-def $group
	done
	return $?
}

print-help () {
	local app=$(basename $0)
	local cmds=$(__commands)
	local max=0
	for cmd in $cmds; do
		[ ${#cmd} -gt $max ] && max=${#cmd}
	done
	(
		if [ $max = 0 ]; then
			printf "usage %s <options>\n" $app
		else
			printf "usage: %s <command> [<options>]\n\n" $app
			printf "The available commands are\n"
			for cmd in $cmds; do
				local msg=$(cat $FILENAME | grep cmd-$cmd.\*\# | sed 's/.*#[ ]*//')
				printf "   %-${max}s   %s\n" $cmd "$msg"
			done
			printf "\nRunning '%s --help' will print this message\n" $app
		fi
	) >&2
}

__commands () {
	declare -F | grep 'cmd-' | sed 's/.*cmd-//' | sed 's/ .*//'
	return $?
}

__autocompletelist () {
	if silent type $@; then
		for word in $($@); do
			echo $word
		done
		exit 0
	fi
}

__autocomplete () {
	if [ "${COMP_CUR:0:1}" = "-" ]; then
		for opt in ${OPTS[@]}; do
			[ "$opt" != "--autocomplete" ] && echo $opt
		done
		exit 0
	fi
	if [ "${COMP_PREV:0:1}" = "-" ] && [ "${#COMP_PREV}" = 2 ]; then
		local opt_alias=opt_alias_${COMP_PREV:1}
		COMP_PREV="--${!opt_alias}"
	fi
	if [ "${COMP_PREV:0:2}" = "--" ]; then
		__autocompletelist tab-${COMP_PREV:2}
		exit 0
	fi

	__autocompletelist tab-$COMP_PREV-$(($COMP_CWORD-1))
	__autocompletelist tab-$COMP_CWORD

	[ "$COMP_CWORD" = "1" ] && __commands && exit 0

	__autocompletelist tab
}

run () {
	if opt --autocomplete; then
		__autocomplete | grep "^$COMP_CUR"
		return 0
	fi
	if opt --help; then
		print-help
		return 0
	fi
	if silent type cmd-${ARGV_[0]}; then
		cmd-${ARGV_[0]} "${ARGV_[@]:1}"
		return $?
	fi
	if silent type sudo-cmd-${ARGV_[0]}; then
		if [ $EUID = 0 ]; then
			sudo-cmd-${ARGV_[0]} "${ARGV_[@]}"
		else
			sudo $FILENAME "${ARGV}"
		fi
		return $?
	fi
	if silent type cmd; then
		cmd "${ARGV_[@]}"
		return $?
	fi

	print-help
	return 1
}

if [ "${BASH_SOURCE[0]}" = "$0" ] || [ "$_" = "$0" ]; then
	BASHKIT_INSTALL="$DIRNAME"
	BASHKIT_BIN="$BASHKIT_INSTALL/bin"
	BASHKIT_APPS="$BASHKIT_INSTALL/apps"

	opt --bin,-b --force,-f
	opt --colors && BASHKIT_COLORS=true

	not-root () {
		[ ! -O $BASHKIT_BIN ] && [ $EUID = 0 ] && not opt --force && error "you are root and do not own bin\nuse --force to continue"
	}

	app-init () {
		[ $# = 0 ] && error app is required
		app_filename=$(basename $1)
		local tmp=${app_filename%.*}
		app_bin=${opt_bin-$tmp}
	}

	app-not-exists () {
		[ -e $BASHKIT_BIN/$app_bin ] && not opt --force && error app already installed
	}

	cmd-link () { # Link a script for development
		not-root
		app-init $1
		app-not-exists
		local link=$BASHKIT_BIN/$app_bin
		touch $BASHKIT_APPS/$app_bin
		cd $(dirname $1)
		rm -f $link
		ln -s $PWD/$app_filename $link
		chmod +x $PWD/$app_filename
	}

	cmd-list () { # List all installed apps
		ls $BASHKIT_APPS | cat -
	}

	tab-has-1 () {
		cmd-list
	}

	cmd-has () { # Test whether an app was installed with bashkit
		app-init $1
		[ -e $BASHKIT_BIN/$1 ] && return 0
		return 1
	}

	cmd-selfdestruct () { # Remove bashkit from this machine
		for app in $(ls $BASHKIT_APPS); do
			rm -f $BASHKIT_BIN/$app
		done
		rm -f $BASHKIT_BIN/bashkit
		rm -rf $BASHKIT_INSTALL
	}

	tab-uninstall-1 () {
		cmd-list
	}

	cmd-uninstall () { # Remove a previously installed or linked app
		[ "$1" = "" ] && error app is required
		local link=$BASHKIT_BIN/$1
		[ ! -e $link ] && not opt --force && error app not found
		rm -f $link
		rm -rf $BASHKIT_APPS/$1
	}

	cmd-install () { # Installs an app from a git repository
		not-root
		app-init $1
		app-not-exists
		local repo=${1/https:\/\/github.com\//}
		local app_dir=$BASHKIT_APPS/$app_bin
		[ "${repo/:/}" = "$repo" ] && [ "${repo/@/}" = "$repo" ] && [ ! -e $repo ] && repo="git://github.com/$repo.git"
		git clone $repo $app_dir || return $?
		for file in {main,$app_bin}{.sh,}; do
			if [ -e $app_dir/$file ]; then
				$FILENAME link $app_dir/$file --bin $app_bin --force
				return $?
			fi
		done
		$FILENAME uninstall $app_bin --force
		error no install target found
	}

	tab-update-1 () {
		cmd-list
	}

	cmd-update () { # Update and previously installed app
		[ ! -e $BASHKIT_APPS/$1/.git ] && error app cannot be updated
		cd $BASHKIT_APPS/$1
		git pull
	}

	cmd-standalone () { # Generate installer that can be used without bashkit
		app-init $1
		cat $DIRNAME/standalone | sed "s|__NAME__|$app_bin|g" | sed "s|__REPO__|$1|g"
	}

	cmd-selfupdate () { # Upgrade bashkit to the newest available version
		cd $BASHKIT_INSTALL
		git pull
	}

	cmd-path () { # Print the include path of bashkit
		echo $FILENAME
	}

	cmd-rc () { # Print the path to the bashkit rc file
		echo $DIRNAME/bashrc
	}

	cmd-dirname () { # Print the install dir of bashkit
		echo $DIRNAME
	}

	run
fi