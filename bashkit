#!/bin/bash

CWD="$PWD"
ARGV="$*"
ARGV_LIST=($*)
OPTS=()
CMD=$1

cd $(dirname $(readlink $0 || echo $0))
DIRNAME=$PWD
FILENAME=$DIRNAME/$(basename $(readlink $0 || echo $0))
cd $CWD

silent () {
	$* > /dev/null 2> /dev/null
	return $?
}

error () {
	echo $* >&2
	exit 1
}

not () {
	$* && return 1 || return 0
}

opt-find () {
	local name=${1//-/}
	local opt_name=opt_$name
	local found=false
	for opt in $*; do
		for arg in ${ARGV_LIST[@]}; do
			[ "$opt" = "$arg" ] && found=true && printf -v $opt_name true && continue
			$found && [ "${arg:0:1}" = "-" ] && break 2
			$found && printf -v $opt_name $arg && break 2
		done
	done
	for alias in ${@:2}; do
		printf -v opt_alias_${alias//-/} $name
	done
	$found && return 0 || return 1
}

opt () {
	if [ "${1:0:1}" != "-" ]; then
		[ "$CMD" != "$1" ] && return 1
		shift
	fi
	local name=opt_${1//-/}
	[ $# = 1 ] && [ "${!name}" != "" ] && return 0
	OPTS+=(${@//,[^ ]*/})
	for group in $*; do
		local IFS=","
		opt-find $group
	done
	return $?
}

print-help () {
	local app=$(basename $0)
	local cmds=$(__commands)
	local max=0

	for cmd in $cmds; do
		[ ${#cmd} -gt $max ] && max=${#cmd}
	done
	(
		if [ $max = 0 ]; then
			printf "usage %s <options>\n" $app
		else
			printf "usage: %s <command> [<options>]\n\n" $app
			printf "The available commands are\n"
			for cmd in $cmds; do
				local msg=$(cat $FILENAME | grep cmd-$cmd.\*\# | sed 's/.*#[ ]*//')
				printf "   %-${max}s   %s\n" $cmd "$msg"
			done
			printf "\nRunning '%s --help' will print this message\n" $app
		fi
	) >&2
}

__commands () {
	declare -F | grep 'cmd-' | sed 's/.*cmd-//' | sed 's/ .*//'
	return $?
}

__autocompletelist () {
	if silent type $*; then
		for word in $($*); do
			echo $word
		done
		exit 0
	fi
}
__autocomplete () {
	if [ "${COMP_CUR:0:1}" = "-" ]; then
		for opt in ${OPTS[@]}; do
			[ "$opt" != "--autocomplete" ] && echo $opt
		done
		exit 0
	fi
	if [ "${COMP_PREV:0:1}" = "-" ] && [ "${#COMP_PREV}" = 2 ]; then
		local opt_alias=opt_alias_${COMP_PREV:1}
		COMP_PREV="--${!opt_alias}"
	fi
	if [ "${COMP_PREV:0:2}" = "--" ]; then
		__autocompletelist tab-${COMP_PREV:2}
		exit 0
	fi

	__autocompletelist tab-$COMP_PREV-$(($COMP_CWORD-1))
	__autocompletelist tab-$COMP_CWORD

	[ "$COMP_CWORD" = "1" ] && __commands && exit 0

	__autocompletelist tab
}

run () {
	if opt --autocomplete; then
		__autocomplete | grep "^$COMP_CUR"
		return 0
	fi
	if opt --help; then
		print-help
		return 0
	fi
	if silent type cmd-$CMD; then
		cmd-$CMD ${ARGV_LIST[@]:1}
		return $?
	fi
	if silent type cmd; then
		cmd $*
		return $?
	fi

	print-help
	return 1
}

if [ "${BASH_SOURCE[0]}" = "$0" ] || [ "$_" = "$0" ]; then
	BASHKIT_BIN="$BASHKIT_INSTALL/bin"

	opt --bin,-b --force,-f

	[ "$(whoami)" = "root" ] && not opt --force && error you are sudo. use --force to continue

	init-app () {
		app_filename=$(basename $1)
		local tmp=${app_filename/.sh/}
		app_bin=${opt_bin-$tmp}
		[ -e $BASHKIT_BIN/$app_bin ] && not opt --force && error app already exists
	}

	cmd-link () { # Link a script for development.
		init-app $1
		local link=$BASHKIT_BIN/$app_bin
		cd $(dirname $1)
		rm -f $link
		ln -s $PWD/$app_filename $link
		chmod +x $PWD/$app_filename
	}

	cmd-ls () { # List all installed apps
		ls $BASHKIT_BIN | grep -v bashkit
	}

	tab-uninstall-1 () {
		cmd-ls
	}

	cmd-selfdestruct () { # Remove bashkit from this machine
		rm -rf $BASHKIT_INSTALL
	}

	cmd-uninstall () { # Remove a previously installed or linked app
		local link=$BASHKIT_BIN/$1
		[ ! -e $link ] && error app not found
		rm -f $link
	}

	cmd-install () { # Installs an app from a filename or url.
		init-app $1
		if [ -e $1 ]; then
			cp $1 $BASHKIT_BIN/$app_bin
		else
			curl $1 > $BASHKIT_BIN/$app_bin
		fi
		chmod +x $BASHKIT_BIN/$app_bin
	}

	cmd-selfupdate () { # Upgrade bashkit to the newest available version
		cd $BASHKIT_INSTALL
		git pull
	}

	cmd-path () { # Print the include path of bashkit
		echo $FILENAME
	}

	run
fi