#!/bin/bash

CWD="$PWD"
ARGV="$*"
ARGV_LIST=($*)
LONG_OPTS=()
CMD=$1

cd $(dirname $(readlink $0 || echo $0))
DIRNAME=$PWD
FILENAME=$DIRNAME/$(basename $(readlink $0 || echo $0))
cd $CWD

silent () {
	$* > /dev/null 2> /dev/null
	return $?
}

error () {
	echo ${@:2}
	exit $1 >&2
}

opt () {
	declare -p opt_$1 > /dev/null 2> /dev/null && return 0
	local found=false
	LONG_OPTS+=(--$1)
	[ "$2" != "" ] && printf -v opt_alias_$2 $1
	for arg in $ARGV; do
		$found && [ "${arg:0:1}" != "-" ] && printf -v opt_$1 $arg
		$found && break
		if [ "--$1" = "$arg" ] || ([ "$2" != "" ] && [ "-$2" = "$arg" ]); then
			found=true
			printf -v opt_$1 true
		fi
	done
	$found && return 0 || return 1
}

print-help () {
	local app=$(basename $0)
	local cmds=$(__commands)
	local max=0

	for cmd in $cmds; do
		[ ${#cmd} -gt $max ] && max=${#cmd}
	done
	(
		if [ $max = 0 ]; then
			printf "usage %s <options>\n" $app
		else
			printf "usage: %s <command> [<options>]\n\n" $app
			printf "The available commands are\n"
			for cmd in $cmds; do
				local msg=$(cat $FILENAME | grep cmd-$cmd.\*\# | sed 's/.*#[ ]*//')
				printf "   %-${max}s   %s\n" $cmd "$msg"
			done
			printf "\nRunning '%s --help' will print this message\n" $app
		fi
	) >&2
}

__commands () {
	declare -F | grep 'cmd-' | sed 's/.*cmd-//' | sed 's/ .*//'
	return $?
}

__autocompletelist () {
	if silent type $*; then
		for word in $($*); do
			echo $word
		done
		exit 0
	fi
}
__autocomplete () {
	if [ "${COMP_CUR:0:2}" = "--" ]; then
		for opt in ${LONG_OPTS[@]}; do
			echo $opt
		done
		exit 0
	fi
	if [ "${COMP_PREV:0:1}" = "-" ] && [ "${#COMP_PREV}" = 2 ]; then
		local opt_alias=opt_alias_${COMP_PREV:1}
		COMP_PREV="--${!opt_alias}"
	fi
	if [ "${COMP_PREV:0:2}" = "--" ]; then
		__autocompletelist tab-${COMP_PREV:2}
		exit 0
	fi

	__autocompletelist tab-$COMP_CWORD
	__autocompletelist tab-$COMP_PREV-$(($COMP_CWORD-1))

	[ $COMP_CWORD = 1 ] && __commands && exit 0

	__autocompletelist tab
}

run () {
	if [ "$CMD" = "__autocomplete" ]; then
		__autocomplete | grep "^$COMP_CUR"
		return 0
	fi
	if opt help; then
		print-help
		return 0
	fi
	if silent type cmd-$CMD; then
		cmd-$CMD ${ARGV_LIST[@]:1}
		return $?
	fi
	if silent type cmd; then
		cmd $*
		return $?
	fi

	print-help
	return 1
}

if [ "${BASH_SOURCE[0]}" = "$0" ] || [ "$_" = "$0" ]; then
	BASHKIT_INSTALL="$HOME/.bashkit"
	BASHKIT_BIN="$BASHKIT_INSTALL/bin"
	opt app a
	opt force f

	opt force || [ $(whoami) = "root" ] && error 1 you are sudo. use --force to continue

	init-app () {
		app_filename=$(basename $1)
		local tmp=$(echo $app_filename | sed 's/.sh//')
		app_bin=${opt_app-$tmp}
		opt force || [ -e $BASHKIT_BIN/$app_bin ] && error 1 app already exists
	}

	link-app () {
		silent type _bashkit_completion_add && _bashkit_completion_add $app_bin
	}

	cmd-link () { # Link a script for development. --app to specify bin name
		init-app $1
		local link=$BASHKIT_BIN/$app_bin
		cd $(dirname $1)
		ln -s $PWD/$app_filename $link
		chmod +x $PWD/$app_filename
		link-app
	}

	cmd-ls () {
		ls $BASHKIT_BIN | grep -v bashkit
	}

	tab-uninstall-1 () {
		cmd-ls
	}

	cmd-selfdestruct () { # Remove bashkit from this machine
		rm -rf $BASHKIT_INSTALL
	}

	cmd-uninstall () { # Remove a previously installed or linked app
		local link=$BASHKIT_BIN/$1
		[ ! -e $link ] && error 1 app not found
		rm -f $link
	}

	cmd-install () { # Installs an app from a filename or url. --app to specify bin name
		init-app $1
		if [ -e $1 ]; then
			cp $1 $BASHKIT_BIN/$app_bin
		else
			curl $1 > $BASHKIT_BIN/$app_bin
		fi
		chmod +x $BASHKIT_BIN/$app_bin
		link-app
	}

	cmd-selfupdate () { # Upgrade bashkit to the newest available version
		cd $BASHKIT_INSTALL
		git pull
	}

	cmd-path () { # Print the include path of bashkit
		echo $FILENAME
	}

	run
fi